{
  "name": "VagrantSpec",
  "tagline": "ServerSpec Testing for Clustered / Distributed Systems in Vagrant",
  "body": "VagrantSpec is a Vagrant plugin that makes integration testing for deployments\r\nto clustered systems a breeze. It also separates the build and deployment steps\r\nto clearly separate pipeline tasks. \r\n\r\nFor a complete tutorial, reference [Welcome to VagrantSpec](https://github.com/miroswan/vagrant_spec/wiki/Welcome-to-VagrantSpec)\r\n\r\n## Installation\r\n\r\n```vagrant plugin install vagrant_spec```\r\n\r\n## Why not use TestKitchen or vagrant-serverspec?\r\n\r\n* Test Kitchen is an excellent integration testing system developed by Chef.\r\nHowever, it is designed to provision, test, and destroy each system one at a\r\ntime. The directory structure it expects makes sharing tests across nodes \r\ndifficult to manage. This is undesireable for testing clustered or \r\ndistributed systems. vagrant-serverspec has similar pitfalls. \r\n\r\n* vagrant_spec allows you to leverage your deployment tools just like you would\r\nin staging and production. It generates an ansible inventory file after all\r\nnodes are brought up. This allows you to run the same ansible_playbook commands\r\nagainst the Vagrant node set as you would elsewhere. \r\n\r\n* routing tests to nodes is flexible and simple. \r\n\r\n* vagrant_spec allows you to provision your nodes with configuration management\r\nand leverage ansible for orchestration and deployment. TestKitchen currently\r\ndoes not support this scenario without much trouble. \r\n\r\n## Sample Vagrantfile\r\n\r\n```\r\nVagrant.configure(2) do |config|\r\n  config.vm.box = 'ubuntu/trusty64'\r\n  \r\n  config.vm.define 'test_ansible' do |b|\r\n    b.vm.hostname = 'ansible'\r\n  end\r\n\r\n  config.vm.define 'test_pansible' do |b|\r\n    b.vm.hostname = 'pansible'\r\n  end\r\n\r\n  # key: Ansible Group Name\r\n  # value: Regexp matching your node names or an array of nodes\r\n  config.spec.ansible_inventory = { 'ansi' => /_ansi/, 'pansi' => /_pansi/ }\r\n\r\n  # nodes: Regexp matching the desired nodes or array of nodes\r\n  # flags: Command line flags you would pass to rspec\r\n  config.spec.test_plan = [\r\n    {\r\n      'nodes' => /test_ansi/,\r\n      'flags' => '--format documentation --color --pattern serverspec/ansi*'\r\n    },\r\n    {\r\n      'nodes' => /test_pansi/,\r\n      'flags' => '--format documentation --color --pattern serverspec/pansi*'\r\n    }\r\n  ]\r\nend\r\n```\r\n\r\n## Configuration\r\n\r\n* config.spec.directory: relative path to your serverspec test files. This \r\ndefaults to serverspec. \r\n\r\n* config.spec.ansible_inventory: a hash that maps ansible groups to your nodes.\r\nYou can specify as many groups as you need. You can match nodes by regular \r\nexpression or explicitly provide an array of node names. This will generate \r\nan vagrantspec_inventory based on your active nodes. You use this file for \r\nrunning ansible playbooks against your Vagrant instances. Use this configuration\r\ndirective if you use ansible for orchestration. \r\n\r\n* config.spec.generate_machine_data: a boolean. If true, the init sub-command\r\nwill generate a json file at .vagrantspec_machine_data containing relevant\r\nssh information for each of your nodes. This can be helpful when leveraging\r\norchestration tooling aside from ansible. You can use this data to direct your\r\norchestration to your local instances. The default is set to true. \r\n\r\n* config.spec.test_plan: an array of hashes. nodes can either be a regular \r\nexpression object that matches your desired nodes or an explicit array of \r\nnodes. flags is a string that matches the desired flags you would pass to\r\nrspec. The last argument is typically a pattern that maps to the tests you'd \r\nlike to run. This allows you to split out what tests you'd like to run across\r\nyour cluster of nodes. \r\n\r\n## Sub Commands\r\n\r\n* version: Print the current version of vagrant_spec\r\n\r\n* init: This will generate your ansible inventory file if you've configured your\r\nconfig.spec.ansible_inventory directive. Additionally, it'll generate your\r\n.vagrantspec_machine_data file if set to enabled via \r\nconfig.spec.generate_machine_data. You'll typically want to run this after a \r\nvagrant up and before your deployment and testing tasks. \r\n\r\n* test: This will run the tests specified in your Vagrantfile. Tests are\r\nexecuted against each node in your fleet and the exit code is stored if an error\r\noccurs. All tests will run. The exit code of the last failed run will return\r\nto the shell. Otherwise, it will return zero. \r\n\r\n## Sample Test Files\r\n\r\n_serverspec/ansible_spec.rb_\r\n\r\n```\r\ndescribe 'Test Hostname' do\r\n  it 'hostname is ansible' do\r\n    expect(command('printf \"$(hostname)\"').stdout).to eq('ansible')\r\n  end\r\nend\r\n```\r\n\r\n_serverspec/pansible_spec.rb_\r\n\r\n```\r\ndescribe 'Test Hostname' do\r\n  it 'hostname is pansible' do\r\n    expect(command('printf \"$(hostname)\"').stdout).to eq('pansible')\r\n  end\r\nend\r\n```\r\n\r\n## Sample Output\r\n\r\n```\r\n> vagrant up\r\n\r\n...\r\n\r\n> vagrant spec init\r\n\r\n> vagrant spec test\r\n\r\n*******************************************************\r\n***************** ServerSpec Test Run *****************\r\n*******************************************************\r\n\r\n[test_ansible]\r\n\r\nTest Hostname\r\n  hostname is ansible\r\n\r\nFinished in 0.43356 seconds (files took 1.61 seconds to load)\r\n1 example, 0 failures\r\n\r\n[test_pansible]\r\n\r\nTest Hostname\r\n  hostname is pansible\r\n\r\nFinished in 0.22762 seconds (files took 0.59837 seconds to load)\r\n1 example, 0 failures\r\n\r\n> echo $?\r\n0\r\n```\r\n\r\n## Testing Resources\r\n\r\n* [ServerSpec](http://serverspec.org/)\r\n* [RSpec](http://rspec.info/)\r\n* [RSpec Best Practices](http://betterspecs.org/)\r\n\r\n## Development\r\n\r\n* Fork the development branch\r\n* ```pip install ansible```\r\n* ```bundle install```\r\n* ```bundle exec rake test```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}